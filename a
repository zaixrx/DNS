#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <cjson/cJSON.h>

#include "sb.h"
#include "types.h"

#define HEADER_SIZE 12

// gets the next byte in buf with incrementing pos
uint8_t getb(struct packet *p) {
	return (uint8_t)p->buf[p->pos++];
}

// little endian processors only bruv skee
uint16_t gets(struct packet *p) {
	return ((uint16_t)getb(p) << 8) | getb(p);
}

uint8_t seekb(struct packet *p) {
	return (uint8_t)p->buf[p->pos];
}

uint32_t getl(struct packet *p) {
	return ((uint32_t)getb(p) << 24) |
	       ((uint32_t)getb(p) << 16) |
	       ((uint32_t)getb(p) << 8)  | getb(p);
}

uint8_t consume_flag(uint16_t *flags, int len) {
	uint8_t ret = *flags & (1 << (len - 1));
	*flags >>= len;
	return ret;
}

int parse_header(struct packet *p, struct header *out) {
	if (!(out && p)) return -1;

	out->ID = gets(p);

	uint16_t flags = gets(p);
	out->flags.RCODE  = consume_flag(&flags, 4);
	out->flags.Z      = consume_flag(&flags, 3);
	out->flags.RA     = consume_flag(&flags, 1);
	out->flags.RD     = consume_flag(&flags, 1);
	out->flags.TC     = consume_flag(&flags, 1);
	out->flags.AA     = consume_flag(&flags, 1);
	out->flags.OPCODE = consume_flag(&flags, 4);
	out->flags.QR     = consume_flag(&flags, 1);

	out->qd_count = gets(p);
	out->an_count = gets(p);
	out->ns_count = gets(p);
	out->ar_count = gets(p);

	return HEADER_SIZE;
}

void print_header(struct header h) {
	printf("ID: %d\n", h.ID);
	printf("RCODE: %d\nZ: %d\nRA: %d\nRD: %d\nTC: %d\nAA: %d\nOPCODE: %d\nQR: %d\n", h.flags.RCODE, h.flags.Z, h.flags.RA, h.flags.RD, h.flags.TC, h.flags.AA, h.flags.OPCODE, h.flags.QR);
	printf("QDCOUNT: %d\n", h.qd_count);
	printf("ANCOUNT: %d\n", h.an_count);
	printf("NSCOUNT: %d\n", h.ns_count);
	printf("ARCOUNT: %d\n", h.ar_count);
}

uint32_t parse_labels(struct packet *p, StringBuilder *strb) {
	char    *buf  = p->buf+p->pos;
	uint8_t  len  = *buf++, next_len = 0;
	uint32_t size = 0;

	while (len > 0) {
		next_len = *(buf+len);
		*(buf+len) = '\0';

		if (strb_append(strb, buf) < 0) return -1;
		*(buf+len) = next_len; // learned that the hard way

		buf  += len+1;
		size += len+1;
		len   = next_len;
	}

	p->pos += size+1;
	return size+1;
}

int parse_questions(struct packet *p, struct question **questions, int questions_count) {
	StringBuilder *strb = strb_create();

	while (--questions_count > 0) {
		uint8_t ptr = getb(p);

		struct question *question = malloc(sizeof(struct question));
		questions[questions_count] = question;

		bool must_return = false;
		int  org_pos     = 0; // meant for referencing

		// the next byte is the index
		uint8_t len = seekb(p);
		if (len == 0xC0) {
			p->pos++;
			int target_index = getb(p);
			org_pos          = p->pos;
			p->pos      	 = target_index;
			must_return 	 = true;
		} 

		if (parse_labels(p, strb) < 0) return -1;
		p->pos = must_return ? org_pos : p->pos;

		if (strb_concat(strb, question->Name) < 0) return -1;
		if (strb_reset(strb) < 0) 		   return -1;

		question->Type   = gets(p);
		question->Class  = gets(p);
	}	

	return strb_free(strb);
}

void print_question(struct question q) {
        cJSON *json = cJSON_CreateObject();
	cJSON_AddStringToObject(json, "Name" , q.Name);
	cJSON_AddNumberToObject(json, "Type" , q.Type);
	cJSON_AddNumberToObject(json, "Class", q.Class);
	printf("Question: %s\n", cJSON_Print(json));
	cJSON_free(json);
	cJSON_Delete(json);
}

int parse_A_records(struct packet *p, struct A_record **records, int records_count) {
	StringBuilder *strb = strb_create();

	while (--records_count >= 0) {
		struct A_record *record = malloc(sizeof(struct A_record));
		records[records_count] = record;

		bool must_return = false;
		int  org_pos     = 0; // meant for referencing

		// the next byte is the index
		if (seekb(p) == 0xC0) {
			p->pos++;
			int target_index = getb(p);
			org_pos          = p->pos;
			p->pos      	 = target_index;
			must_return 	 = true;
		} 

		int size = parse_labels(p, strb);
		p->pos = must_return ? org_pos : p->pos;

		if (size < 0)             return -1;
		if (strb_reset(strb) < 0) return -1;

		record->Type   = gets(p);
		record->Class  = gets(p);
		record->TTL    = getl(p);
		record->Len    = gets(p); // I think I am supposed to identify the NS record type via it's length
		uint32_t nipv4 = ntohl(getl(p));

		inet_ntop(AF_INET, &nipv4, record->IPv4, sizeof record->IPv4);
	}

	return strb_free(strb);
}

void print_record(struct A_record record) {
	cJSON *r_json = cJSON_CreateObject();

	cJSON_AddStringToObject(r_json, "Name", record.Name);
	cJSON_AddStringToObject(r_json, "IPv4", record.IPv4);
	cJSON_AddNumberToObject(r_json, "Type", record.Type);
	cJSON_AddNumberToObject(r_json, "Class", record.Class);
	cJSON_AddNumberToObject(r_json, "TTL", record.TTL);

	printf("A: %s\n", cJSON_Print(r_json));
}

int main(int argc, char **argv) {
	if (argc != 2) {
		fprintf(stderr, "usage: %s <header>\n", argv[0]);
		return EXIT_FAILURE;
	}

	int fd = open(argv[1], O_RDONLY);
	if (fd < 0) {
		fprintf(stderr, "couldn't open file %s\n", argv[1]);
		return EXIT_FAILURE;
	}

	struct packet p = {0};
	if ((p.size = read(fd, p.buf, BUFF_SIZE)) < 0) {
		fprintf(stderr, "couldn't read from opened file %s\n", argv[1]);
		return EXIT_FAILURE;
	}
	close(fd);

	struct header h = {0};
	if (parse_header(&p, &h) < 0) {
		fprintf(stderr, "could not parse header!\n");
		return EXIT_FAILURE;
	}
	print_header(h);

	struct question **questions = malloc(h.qd_count * sizeof(struct question));
	if (parse_questions(&p, questions, h.qd_count) < 0) {
		fprintf(stderr, "failed to parse questions\n");
		free(questions);
		return -1;
	}

	while (h.qd_count-- > 0) {
		print_question(*questions[h.an_count]);
		free(questions[h.an_count]);
	}
	free(questions);

	if (h.flags.QR) {
		struct A_record **records = malloc(h.an_count * sizeof(struct A_record*));
		if (parse_A_records(&p, records, h.an_count) < 0) {
			fprintf(stderr, "failed to parse A records\n");
			free   (records);
			return EXIT_FAILURE;
		}

		while (h.an_count-- > 0) {
			print_record(*records[h.an_count]);
			free(records[h.an_count]);
		}

		free(records);
	}

	return EXIT_SUCCESS;
}
